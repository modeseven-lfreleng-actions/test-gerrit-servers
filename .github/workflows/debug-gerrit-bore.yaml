---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# Debug Gerrit Deployment with Optional External Tunnel Access
#
# This workflow starts a Gerrit container for debugging/testing, with optional
# external tunnel access for remote connectivity.
#
# When tunnels are enabled (default), the workflow:
#   1. Sets up the tunnel (currently using Bore)
#   2. Extracts the assigned public host/ports
#   3. Passes tunnel config to gerrit-action for public URL configuration
#
# When tunnels are disabled, Gerrit runs with localhost access only.

name: "Debug Gerrit Deployment üîß"

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
    inputs:
      server_slug:
        description: "Gerrit server to debug (from GERRIT_SERVERS)"
        required: true
        default: "onap"
        type: string
      debug_minutes:
        description: "Minutes to keep tunnel open (max 60)"
        required: false
        default: 15
        type: number
      sync_on_startup:
        description: "Trigger replication after startup"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      use_api_path:
        # e.g., /r, /infra
        description: "Match origin server URL API path"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"
      enable_tunnel:
        description: "Enable tunnel for remote access"
        required: false
        default: true
        type: boolean

concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: true

permissions: {}

jobs:
  debug-gerrit:
    name: "Debug Gerrit Deployment"
    runs-on: ubuntu-latest
    timeout-minutes: 65
    permissions:
      contents: read
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9  # v2.14.1
        with:
          egress-policy: audit

      - name: "Validate inputs"
        id: validate
        env:
          DEBUG_MINUTES: ${{ inputs.debug_minutes || 30 }}
        run: |
          # Validate debug_minutes input
          if ! [[ "$DEBUG_MINUTES" =~ ^[0-9]+$ ]]; then
            echo "::error::debug_minutes must be an integer: $DEBUG_MINUTES"
            exit 1
          fi
          if [ "$DEBUG_MINUTES" -gt 60 ]; then
            echo "::warning::debug_minutes capped at 60 (was: $DEBUG_MINUTES)"
            DEBUG_MINUTES=60
          fi
          if [ "$DEBUG_MINUTES" -lt 5 ]; then
            echo "::warning::debug_minutes minimum is 5 (was: $DEBUG_MINUTES)"
            DEBUG_MINUTES=5
          fi
          echo "debug_minutes=$DEBUG_MINUTES" >> "$GITHUB_OUTPUT"
          echo "Validated debug_minutes: $DEBUG_MINUTES"

      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: "Lookup server config"
        id: server
        env:
          GERRIT_SERVERS: ${{ vars.GERRIT_SERVERS }}
          SERVER_SLUG: ${{ inputs.server_slug }}
        run: |
          # Lookup server configuration from GERRIT_SERVERS variable
          if [ -z "$GERRIT_SERVERS" ]; then
            echo "::error::GERRIT_SERVERS variable is not set"
            exit 1
          fi

          SERVER=$(echo "$GERRIT_SERVERS" | \
            jq -r --arg slug "$SERVER_SLUG" '.[] | select(.slug == $slug)')

          if [ -z "$SERVER" ]; then
            echo "::error::No server found for slug: $SERVER_SLUG"
            echo "Available slugs:"
            echo "$GERRIT_SERVERS" | jq -r '.[].slug'
            exit 1
          fi

          # Extract server details
          # shellcheck disable=SC2129
          echo "name=$(echo "$SERVER" | jq -r '.name')" >> "$GITHUB_OUTPUT"
          echo "gerrit=$(echo "$SERVER" | jq -r '.gerrit')" >> "$GITHUB_OUTPUT"
          API_PATH=$(echo "$SERVER" | jq -r '.api_path')
          echo "api_path=$API_PATH" >> "$GITHUB_OUTPUT"
          PROJECT_FILTER=$(echo "$SERVER" | jq -r '.project_filter // ""')
          echo "project_filter=$PROJECT_FILTER" >> "$GITHUB_OUTPUT"

          echo "Server: $(echo "$SERVER" | jq -r '.name')"
          echo "Gerrit: $(echo "$SERVER" | jq -r '.gerrit')"

      - name: "Lookup credentials"
        id: credentials
        env:
          GERRIT_CREDENTIALS_B64: ${{ secrets.GERRIT_CREDENTIALS }}
          SERVER_SLUG: ${{ inputs.server_slug }}
        run: |
          # Lookup credentials for this server
          if [ -z "$GERRIT_CREDENTIALS_B64" ]; then
            echo "::error::GERRIT_CREDENTIALS secret is not set"
            exit 1
          fi

          GERRIT_CREDENTIALS=$(echo "$GERRIT_CREDENTIALS_B64" \
            | base64 -d 2>/dev/null)
          if [ -z "$GERRIT_CREDENTIALS" ]; then
            echo "::error::Failed to decode GERRIT_CREDENTIALS"
            exit 1
          fi

          CREDS=$(echo "$GERRIT_CREDENTIALS" | \
            jq -r --arg slug "$SERVER_SLUG" '.[] | select(.slug == $slug)')

          if [ -z "$CREDS" ]; then
            echo "::error::No credentials found for slug: $SERVER_SLUG"
            exit 1
          fi

          USERNAME=$(echo "$CREDS" | jq -r '.username')
          PASSWORD=$(echo "$CREDS" | jq -r '.password')
          echo "::add-mask::$PASSWORD"
          echo "username=$USERNAME" >> "$GITHUB_OUTPUT"
          echo "password=$PASSWORD" >> "$GITHUB_OUTPUT"

      # ================================================================
      # TUNNEL SETUP (optional, before Gerrit)
      # ================================================================
      # External tunnel access allows remote connectivity to the Gerrit
      # container running on the GitHub Actions runner.
      #
      # The tunnel setup produces:
      #   - tunnel_host: The public hostname/IP for access
      #   - tunnel_ports: JSON mapping of slug to {http, ssh} ports
      #
      # Currently using Bore (bore.pub) for public TCP tunnels.
      # Bore tunnels connect on-demand, so they can be started before
      # the local ports are listening. No authentication required.
      # ================================================================

      - name: "Calculate local ports"
        id: ports
        if: inputs.enable_tunnel
        run: |
          # Calculate deterministic local ports
          # These match what gerrit-action will use (BASE_PORT + index)
          # For single-instance debug, index is always 0
          BASE_HTTP_PORT=8080
          BASE_SSH_PORT=29418
          INDEX=0

          HTTP_PORT=$((BASE_HTTP_PORT + INDEX))
          SSH_PORT=$((BASE_SSH_PORT + INDEX))

          {
            echo "http_port=$HTTP_PORT"
            echo "ssh_port=$SSH_PORT"
          } >> "$GITHUB_OUTPUT"

          echo "Local ports calculated:"
          echo "  HTTP: $HTTP_PORT"
          echo "  SSH:  $SSH_PORT"

      # Bore: Install tunnel client
      - name: "Install bore"
        if: inputs.enable_tunnel
        run: |
          # Install bore TCP tunnel client
          BORE_VERSION="0.5.2"
          BORE_URL="https://github.com/ekzhang/bore/releases/download"
          BORE_FILE="bore-v${BORE_VERSION}-x86_64-unknown-linux-musl.tar.gz"

          echo "Downloading bore v${BORE_VERSION}..."
          curl -sSL "${BORE_URL}/v${BORE_VERSION}/${BORE_FILE}" | tar xz

          # Verify installation
          ./bore --version
          sudo mv bore /usr/local/bin/
          echo "bore installed successfully ‚úÖ"

      # Bore: Start tunnels to bore.pub
      - name: "Start bore tunnels"
        id: tunnels
        if: inputs.enable_tunnel
        env:
          LOCAL_HTTP: ${{ steps.ports.outputs.http_port }}
          LOCAL_SSH: ${{ steps.ports.outputs.ssh_port }}
          SERVER_SLUG: ${{ inputs.server_slug }}
        run: |
          # Start bore tunnels BEFORE Gerrit container
          # bore doesn't need local ports to be listening - connects on-demand
          echo "Starting bore tunnels to bore.pub..."
          echo "  (Local ports don't need to be listening yet)"

          # Start HTTP tunnel
          bore local "$LOCAL_HTTP" --to bore.pub > bore-http.log 2>&1 &
          HTTP_PID=$!

          # Start SSH tunnel
          bore local "$LOCAL_SSH" --to bore.pub > bore-ssh.log 2>&1 &
          SSH_PID=$!

          {
            echo "http_pid=$HTTP_PID"
            echo "ssh_pid=$SSH_PID"
            echo "local_http_port=$LOCAL_HTTP"
            echo "local_ssh_port=$LOCAL_SSH"
          } >> "$GITHUB_OUTPUT"

          # Wait for tunnels to establish (with timeout)
          echo "Waiting for tunnels to establish..."
          MAX_WAIT=30
          WAIT_INTERVAL=2
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))

            # Check if bore processes are still running
            HTTP_RUNNING=true
            SSH_RUNNING=true
            if ! kill -0 "$HTTP_PID" 2>/dev/null; then
              HTTP_RUNNING=false
            fi
            if ! kill -0 "$SSH_PID" 2>/dev/null; then
              SSH_RUNNING=false
            fi

            # Check for success in logs
            HTTP_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
              bore-http.log 2>/dev/null || echo "")
            SSH_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
              bore-ssh.log 2>/dev/null || echo "")

            # If both tunnels have ports, we're done
            if [ -n "$HTTP_PORT" ] && [ -n "$SSH_PORT" ]; then
              echo "Tunnels established after ${ELAPSED}s"
              break
            fi

            # If a process died without getting a port, fail early
            if [ "$HTTP_RUNNING" = "false" ] && [ -z "$HTTP_PORT" ]; then
              echo "HTTP tunnel process exited unexpectedly"
              break
            fi
            if [ "$SSH_RUNNING" = "false" ] && [ -z "$SSH_PORT" ]; then
              echo "SSH tunnel process exited unexpectedly"
              break
            fi

            echo "  Waiting... (${ELAPSED}s/${MAX_WAIT}s)"
          done

          # Final port extraction
          HTTP_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
            bore-http.log 2>/dev/null || echo "")
          SSH_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
            bore-ssh.log 2>/dev/null || echo "")

          # Determine if tunnels succeeded
          if [ -n "$HTTP_PORT" ] && [ -n "$SSH_PORT" ]; then
            # Build tunnel_ports JSON for gerrit-action
            TUNNEL_PORTS=$(jq -n \
              --arg slug "$SERVER_SLUG" \
              --argjson http "$HTTP_PORT" \
              --argjson ssh "$SSH_PORT" \
              '{($slug): {http: $http, ssh: $ssh}}')

            {
              echo "tunnels_ok=true"
              echo "bore_host=bore.pub"
              echo "http_port=$HTTP_PORT"
              echo "ssh_port=$SSH_PORT"
              echo "tunnel_ports=$TUNNEL_PORTS"
            } >> "$GITHUB_OUTPUT"

            echo "Bore tunnels established successfully ‚úÖ"
            echo "  HTTP: bore.pub:$HTTP_PORT -> localhost:$LOCAL_HTTP"
            echo "  SSH:  bore.pub:$SSH_PORT -> localhost:$LOCAL_SSH"
            echo ""
            echo "Tunnel ports JSON: $TUNNEL_PORTS"
          else
            # Tunnel setup failed - fatal error
            # Extract first line of error (remove newlines)
            HTTP_ERR=$(head -1 bore-http.log 2>/dev/null || echo "unknown")
            SSH_ERR=$(head -1 bore-ssh.log 2>/dev/null || echo "unknown")

            echo ""
            echo "‚ùå Bore tunnel setup failed"
            # Show single error if both are identical (e.g., control port down)
            if [ "$HTTP_ERR" = "$SSH_ERR" ]; then
              echo "  Error: $HTTP_ERR"
            else
              [ -z "$HTTP_PORT" ] && echo "  HTTP: $HTTP_ERR"
              [ -z "$SSH_PORT" ] && echo "  SSH: $SSH_ERR"
            fi
            echo ""

            # Write GitHub Job Summary
            {
              echo "## ‚ùå Bore Tunnel Setup Failed"
              echo ""
              if [ "$HTTP_ERR" = "$SSH_ERR" ]; then
                echo "$HTTP_ERR"
              else
                [ -z "$HTTP_PORT" ] && echo "- **HTTP:** $HTTP_ERR"
                [ -z "$SSH_PORT" ] && echo "- **SSH:** $SSH_ERR"
              fi
              echo ""
              echo "bore.pub may be down, or port 7835 is blocked."
            } >> "$GITHUB_STEP_SUMMARY"

            echo "::error::Bore tunnel setup failed. Check job summary."
            exit 1
          fi

      # ================================================================
      # START GERRIT
      # ================================================================

      - name: "Start Gerrit mirror"
        id: gerrit
        # yamllint disable-line rule:line-length
        uses: modeseven-lfreleng-actions/gerrit-action@refactor-replication  # Testing
        with:
          gerrit_setup: |
            [{
              "project": "${{ steps.server.outputs.project_filter }}",
              "slug": "${{ inputs.server_slug }}",
              "gerrit": "${{ steps.server.outputs.gerrit }}",
              "api_path": "${{ steps.server.outputs.api_path }}"
            }]
          auth_type: http_basic
          http_username: ${{ steps.credentials.outputs.username }}
          http_password: ${{ steps.credentials.outputs.password }}
          ssh_auth_keys: ${{ vars.GERRIT_PUBLIC_KEYS }}
          ssh_auth_username: 'modesevenindustrialsolutions'
          sync_on_startup: ${{ inputs.sync_on_startup }}
          use_api_path: ${{ inputs.use_api_path }}
          debug: "true"
          check_service: true
          exit: false
          # Pass tunnel config - Gerrit uses these URLs from the start
          # (tunnels are guaranteed to be working if we reach this step)
          tunnel_host: ${{ inputs.enable_tunnel && 'bore.pub' || '' }}
          tunnel_ports: ${{ steps.tunnels.outputs.tunnel_ports }}

      - name: "Verify tunnel connectivity"
        if: inputs.enable_tunnel
        env:
          BORE_HOST: ${{ steps.tunnels.outputs.bore_host }}
          HTTP_PORT: ${{ steps.tunnels.outputs.http_port }}
          API_PATH: ${{ steps.server.outputs.api_path }}
          USE_API_PATH: ${{ inputs.use_api_path }}
        run: |
          # Verify the tunnel is working by hitting Gerrit through it
          echo "Verifying tunnel connectivity..."

          # Compute effective API path
          EFFECTIVE_API_PATH=""
          if [ "${USE_API_PATH:-false}" = "true" ] && [ -n "$API_PATH" ]; then
            EFFECTIVE_API_PATH="$API_PATH"
          fi

          # Build URL
          if [ -n "$EFFECTIVE_API_PATH" ]; then
            URL="http://${BORE_HOST}:${HTTP_PORT}${EFFECTIVE_API_PATH}/config/server/version"
          else
            URL="http://${BORE_HOST}:${HTTP_PORT}/config/server/version"
          fi

          echo "Testing: $URL"

          # Try a few times (tunnel might need a moment)
          MAX_ATTEMPTS=5
          for i in $(seq 1 $MAX_ATTEMPTS); do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            if echo "$HTTP_CODE" | grep -q "200"; then
              VERSION=$(curl -s "$URL" | tr -d '")' | tail -1)
              echo "Tunnel verified ‚úÖ (Gerrit $VERSION)"
              exit 0
            fi
            echo "  Attempt $i/$MAX_ATTEMPTS failed, retrying..."
            sleep 3
          done

          echo "::warning::Could not verify tunnel connectivity"
          echo "Gerrit may still be starting up"

      - name: "Display connection info"
        env:
          USE_BORE: ${{ inputs.enable_tunnel }}
          TUNNEL_BORE_HOST: ${{ steps.tunnels.outputs.bore_host }}
          TUNNEL_HTTP_PORT: ${{ steps.tunnels.outputs.http_port }}
          TUNNEL_SSH_PORT: ${{ steps.tunnels.outputs.ssh_port }}
          TUNNEL_LOCAL_HTTP: ${{ steps.tunnels.outputs.local_http_port }}
          TUNNEL_LOCAL_SSH: ${{ steps.tunnels.outputs.local_ssh_port }}
          DEBUG_MINUTES: ${{ steps.validate.outputs.debug_minutes }}
          SERVER_NAME: ${{ steps.server.outputs.name }}
          API_PATH: ${{ steps.server.outputs.api_path }}
          SERVER_SLUG: ${{ inputs.server_slug }}
          USE_API_PATH: ${{ inputs.use_api_path }}
        run: |
          # Display connection information
          # Set connection variables based on tunnel usage
          if [ "$USE_BORE" = "true" ]; then
            BORE_HOST="$TUNNEL_BORE_HOST"
            HTTP_PORT="$TUNNEL_HTTP_PORT"
            SSH_PORT="$TUNNEL_SSH_PORT"
            LOCAL_HTTP="$TUNNEL_LOCAL_HTTP"
            LOCAL_SSH="$TUNNEL_LOCAL_SSH"
          else
            BORE_HOST="localhost"
            HTTP_PORT="8080"
            SSH_PORT="29418"
            LOCAL_HTTP="8080"
            LOCAL_SSH="29418"
          fi

          # Build tunnel info array for iteration
          declare -a TUNNELS=()

          # Compute effective_api_path based on USE_API_PATH
          EFFECTIVE_API_PATH=""
          if [ "${USE_API_PATH:-false}" = "true" ] && [ -n "$API_PATH" ]; then
            EFFECTIVE_API_PATH="$API_PATH"
          fi

          # Build tunnel info - BORE_HOST is bore.pub (tunnels guaranteed)
          if [ -n "$HTTP_PORT" ]; then
            if [ -n "$EFFECTIVE_API_PATH" ]; then
              HTTP_URL="http://${BORE_HOST}:${HTTP_PORT}${EFFECTIVE_API_PATH}/"
            else
              HTTP_URL="http://${BORE_HOST}:${HTTP_PORT}/"
            fi
            TUNNELS+=("http|Web UI|$LOCAL_HTTP|$HTTP_PORT|$HTTP_URL")
          fi
          if [ -n "$SSH_PORT" ]; then
            SSH_URL="ssh://admin@${BORE_HOST}:${SSH_PORT}"
            TUNNELS+=("ssh|SSH/Git|$LOCAL_SSH|$SSH_PORT|$SSH_URL")
          fi

          {
            echo "# üîß Debug Session: $SERVER_NAME"
            echo ""
            echo "## üåê Public Access Ports"
            echo ""
            echo "| Service | Local Port | Public Port | Public URL |"
            echo "|---------|------------|-------------|------------|"

            for t in "${TUNNELS[@]}"; do
              IFS='|' read -r _ LABEL LOCAL PUBLIC URL <<< "$t"
              echo "| **$LABEL** | $LOCAL | $PUBLIC | \`$URL\` |"
            done

            echo ""
            echo "## üîó Quick Access"
            echo ""

            if [ -n "$HTTP_PORT" ]; then
              echo "### Gerrit Web Portal"
              echo ""
              if [ -n "$EFFECTIVE_API_PATH" ]; then
                echo "**URL**: http://$BORE_HOST:$HTTP_PORT$EFFECTIVE_API_PATH/"
              else
                echo "**URL**: http://$BORE_HOST:$HTTP_PORT/"
              fi
              echo ""
              echo '```bash'
              echo "# Check version"
              if [ -n "$EFFECTIVE_API_PATH" ]; then
                URL="http://$BORE_HOST:$HTTP_PORT$EFFECTIVE_API_PATH"
              else
                URL="http://$BORE_HOST:$HTTP_PORT"
              fi
              echo "curl -s $URL/config/server/version"
              echo ""
              echo "# List projects"
              echo "curl -s $URL/projects/"
              echo '```'
              echo ""
            fi

            if [ -n "$SSH_PORT" ]; then
              echo "### SSH Access"
              echo ""
              echo '```bash'
              echo "# Test connection"
              echo "ssh -p $SSH_PORT admin@$BORE_HOST gerrit version"
              echo ""
              echo "# Clone a repository"
              echo "git clone ssh://admin@$BORE_HOST:$SSH_PORT/PROJECT_NAME"
              echo '```'
              echo ""
            fi

            echo "## ‚è±Ô∏è Session Info"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| Server | $SERVER_NAME (\`$SERVER_SLUG\`) |"
            echo "| Duration | $DEBUG_MINUTES minutes |"
            DATE_FMT='+%Y-%m-%d %H:%M:%S %Z'
            EXPIRY=$(date -d "+$DEBUG_MINUTES minutes" "$DATE_FMT" \
              2>/dev/null || date -v+"${DEBUG_MINUTES}"M "$DATE_FMT")
            echo "| Expires | $EXPIRY |"
            echo ""
            if [ "$USE_BORE" = "true" ]; then
              echo "> ‚ö†Ô∏è **Warning**: URLs are publicly accessible!"
            else
              echo "> ‚ÑπÔ∏è **Note**: Local access only (external tunnel disabled)"
            fi
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          # Console output
          echo ""
          echo "========================================"
          echo "  DEBUG SESSION ACTIVE"
          echo "========================================"
          for t in "${TUNNELS[@]}"; do
            IFS='|' read -r _ LABEL _ _ URL <<< "$t"
            printf "  %-10s %s\n" "$LABEL:" "$URL"
          done
          echo "  Duration:  $DEBUG_MINUTES minutes"
          echo "========================================"
          echo ""

      - name: "Keep session alive"
        env:
          DEBUG_MINUTES: ${{ steps.validate.outputs.debug_minutes }}
          USE_BORE: ${{ inputs.enable_tunnel }}
        run: |
          # Keep the session alive for the specified duration
          echo "Session will remain active for $DEBUG_MINUTES minutes..."
          echo "Cancel the workflow manually when you're done debugging."
          echo ""

          # Sleep with periodic status updates
          TOTAL_SECONDS=$((DEBUG_MINUTES * 60))
          ELAPSED=0
          INTERVAL=60

          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            REMAINING=$(( (TOTAL_SECONDS - ELAPSED) / 60 ))
            echo "[$(date '+%H:%M:%S')] $REMAINING minutes remaining..."

            # Check if tunnels are still running (only when bore is enabled)
            if [ "$USE_BORE" = "true" ]; then
              if ! pgrep -f "bore local" > /dev/null; then
                echo "::warning::bore tunnels have stopped unexpectedly"
                echo "HTTP tunnel log:"
                cat bore-http.log 2>/dev/null || echo "(no log)"
                echo "SSH tunnel log:"
                cat bore-ssh.log 2>/dev/null || echo "(no log)"
              fi
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "Debug session time expired."

      - name: "Cleanup"
        if: always()
        env:
          CONTAINER_IDS: ${{ steps.gerrit.outputs.container_ids }}
          USE_BORE: ${{ inputs.enable_tunnel }}
        run: |
          # Cleanup tunnels and containers
          echo "Cleaning up..."

          # Stop bore tunnels (only when bore is enabled)
          if [ "$USE_BORE" = "true" ]; then
            pkill -f "bore local" 2>/dev/null || true
          fi

          # Stop and remove Gerrit containers
          if [ -n "$CONTAINER_IDS" ]; then
            echo "$CONTAINER_IDS" | jq -r '.[]' 2>/dev/null | \
              while IFS= read -r cid; do
                [ -z "$cid" ] && continue
                echo "Stopping container: $cid"
                docker kill "$cid" 2>/dev/null || true
                echo "Removing container: $cid"
                docker rm "$cid" 2>/dev/null || true
              done
          fi

          echo "Cleanup complete ‚úÖ"
