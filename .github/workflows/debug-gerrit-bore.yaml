---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# Debug Gerrit with remote access via bore tunnel
#
# This workflow starts bore tunnels BEFORE the Gerrit container, allowing
# the container to be configured with the correct public URLs from the start.
# This eliminates the fragile config-patch-and-restart sequence that was
# previously required.
#
# How it works:
# 1. Calculate deterministic local ports based on instance index
# 2. Start bore tunnels pointing to those ports (bore doesn't require
#    the local port to be listening - it connects on-demand)
# 3. Extract the assigned public ports from bore
# 4. Pass tunnel config to gerrit-action, which configures Gerrit with
#    the public URLs from the start
# 5. No container restart needed!

name: "Debug Gerrit (bore tunnel) üîß"

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
    inputs:
      server_slug:
        description: "Gerrit server to debug (from GERRIT_SERVERS)"
        required: true
        default: "onap"
        type: string
      debug_minutes:
        description: "Minutes to keep tunnel open (max 60)"
        required: false
        default: 15
        type: number
      sync_on_startup:
        description: "Trigger replication after startup"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      use_api_path:
        # e.g., /r, /infra
        description: "Match origin server URL API path"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"

concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: true

permissions: {}

jobs:
  debug-gerrit:
    name: "Debug Gerrit via bore tunnel"
    runs-on: ubuntu-latest
    timeout-minutes: 65
    permissions:
      contents: read
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: "Validate inputs"
        id: validate
        env:
          DEBUG_MINUTES: ${{ inputs.debug_minutes || 30 }}
        run: |
          # Validate debug_minutes input
          if ! [[ "$DEBUG_MINUTES" =~ ^[0-9]+$ ]]; then
            echo "::error::debug_minutes must be an integer: $DEBUG_MINUTES"
            exit 1
          fi
          if [ "$DEBUG_MINUTES" -gt 60 ]; then
            echo "::warning::debug_minutes capped at 60 (was: $DEBUG_MINUTES)"
            DEBUG_MINUTES=60
          fi
          if [ "$DEBUG_MINUTES" -lt 5 ]; then
            echo "::warning::debug_minutes minimum is 5 (was: $DEBUG_MINUTES)"
            DEBUG_MINUTES=5
          fi
          echo "debug_minutes=$DEBUG_MINUTES" >> "$GITHUB_OUTPUT"
          echo "Validated debug_minutes: $DEBUG_MINUTES"

      - name: "Checkout repository"
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: "Lookup server config"
        id: server
        env:
          GERRIT_SERVERS: ${{ vars.GERRIT_SERVERS }}
          SERVER_SLUG: ${{ inputs.server_slug }}
        run: |
          # Lookup server configuration from GERRIT_SERVERS variable
          if [ -z "$GERRIT_SERVERS" ]; then
            echo "::error::GERRIT_SERVERS variable is not set"
            exit 1
          fi

          SERVER=$(echo "$GERRIT_SERVERS" | \
            jq -r --arg slug "$SERVER_SLUG" '.[] | select(.slug == $slug)')

          if [ -z "$SERVER" ]; then
            echo "::error::No server found for slug: $SERVER_SLUG"
            echo "Available slugs:"
            echo "$GERRIT_SERVERS" | jq -r '.[].slug'
            exit 1
          fi

          # Extract server details
          # shellcheck disable=SC2129
          echo "name=$(echo "$SERVER" | jq -r '.name')" >> "$GITHUB_OUTPUT"
          echo "gerrit=$(echo "$SERVER" | jq -r '.gerrit')" >> "$GITHUB_OUTPUT"
          API_PATH=$(echo "$SERVER" | jq -r '.api_path')
          echo "api_path=$API_PATH" >> "$GITHUB_OUTPUT"
          PROJECT_FILTER=$(echo "$SERVER" | jq -r '.project_filter // ""')
          echo "project_filter=$PROJECT_FILTER" >> "$GITHUB_OUTPUT"

          echo "Server: $(echo "$SERVER" | jq -r '.name')"
          echo "Gerrit: $(echo "$SERVER" | jq -r '.gerrit')"

      - name: "Lookup credentials"
        id: credentials
        env:
          GERRIT_CREDENTIALS_B64: ${{ secrets.GERRIT_CREDENTIALS }}
          SERVER_SLUG: ${{ inputs.server_slug }}
        run: |
          # Lookup credentials for this server
          if [ -z "$GERRIT_CREDENTIALS_B64" ]; then
            echo "::error::GERRIT_CREDENTIALS secret is not set"
            exit 1
          fi

          GERRIT_CREDENTIALS=$(echo "$GERRIT_CREDENTIALS_B64" \
            | base64 -d 2>/dev/null)
          if [ -z "$GERRIT_CREDENTIALS" ]; then
            echo "::error::Failed to decode GERRIT_CREDENTIALS"
            exit 1
          fi

          CREDS=$(echo "$GERRIT_CREDENTIALS" | \
            jq -r --arg slug "$SERVER_SLUG" '.[] | select(.slug == $slug)')

          if [ -z "$CREDS" ]; then
            echo "::error::No credentials found for slug: $SERVER_SLUG"
            exit 1
          fi

          USERNAME=$(echo "$CREDS" | jq -r '.username')
          PASSWORD=$(echo "$CREDS" | jq -r '.password')
          echo "::add-mask::$PASSWORD"
          echo "username=$USERNAME" >> "$GITHUB_OUTPUT"
          echo "password=$PASSWORD" >> "$GITHUB_OUTPUT"

      # ================================================================
      # TUNNEL SETUP - BEFORE GERRIT
      # ================================================================
      # We start bore tunnels BEFORE Gerrit so we know the public ports
      # before the container starts. This allows Gerrit to be configured
      # with the correct canonicalWebUrl and sshd.advertisedAddress from
      # the beginning, eliminating the need for container restart.
      #
      # Key insight: bore doesn't require the local port to be listening
      # when the tunnel is established. It only connects to localhost
      # when an actual incoming connection arrives (lazy/on-demand).
      # ================================================================

      - name: "Calculate local ports"
        id: ports
        run: |
          # Calculate deterministic local ports
          # These match what gerrit-action will use (BASE_PORT + index)
          # For single-instance debug, index is always 0
          BASE_HTTP_PORT=8080
          BASE_SSH_PORT=29418
          INDEX=0

          HTTP_PORT=$((BASE_HTTP_PORT + INDEX))
          SSH_PORT=$((BASE_SSH_PORT + INDEX))

          {
            echo "http_port=$HTTP_PORT"
            echo "ssh_port=$SSH_PORT"
          } >> "$GITHUB_OUTPUT"

          echo "Local ports calculated:"
          echo "  HTTP: $HTTP_PORT"
          echo "  SSH:  $SSH_PORT"

      - name: "Install bore"
        run: |
          # Install bore TCP tunnel client
          BORE_VERSION="0.5.2"
          BORE_URL="https://github.com/ekzhang/bore/releases/download"
          BORE_FILE="bore-v${BORE_VERSION}-x86_64-unknown-linux-musl.tar.gz"

          echo "Downloading bore v${BORE_VERSION}..."
          curl -sSL "${BORE_URL}/v${BORE_VERSION}/${BORE_FILE}" | tar xz

          # Verify installation
          ./bore --version
          sudo mv bore /usr/local/bin/
          echo "bore installed successfully ‚úÖ"

      - name: "Start bore tunnels"
        id: tunnels
        env:
          LOCAL_HTTP: ${{ steps.ports.outputs.http_port }}
          LOCAL_SSH: ${{ steps.ports.outputs.ssh_port }}
          SERVER_SLUG: ${{ inputs.server_slug }}
        run: |
          # Start bore tunnels BEFORE Gerrit container
          # bore doesn't need local ports to be listening - connects on-demand
          echo "Starting bore tunnels to bore.pub..."
          echo "  (Local ports don't need to be listening yet)"

          # Start HTTP tunnel
          bore local "$LOCAL_HTTP" --to bore.pub > bore-http.log 2>&1 &
          HTTP_PID=$!

          # Start SSH tunnel
          bore local "$LOCAL_SSH" --to bore.pub > bore-ssh.log 2>&1 &
          SSH_PID=$!

          {
            echo "http_pid=$HTTP_PID"
            echo "ssh_pid=$SSH_PID"
            echo "local_http_port=$LOCAL_HTTP"
            echo "local_ssh_port=$LOCAL_SSH"
          } >> "$GITHUB_OUTPUT"

          # Wait for tunnels to establish
          echo "Waiting for tunnels to establish..."
          sleep 10

          # Extract assigned ports from logs
          HTTP_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
            bore-http.log || echo "")
          SSH_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
            bore-ssh.log || echo "")

          # Determine if tunnels succeeded and set appropriate host/ports
          if [ -n "$HTTP_PORT" ] && [ -n "$SSH_PORT" ]; then
            # Build tunnel_ports JSON for gerrit-action
            TUNNEL_PORTS=$(jq -n \
              --arg slug "$SERVER_SLUG" \
              --argjson http "$HTTP_PORT" \
              --argjson ssh "$SSH_PORT" \
              '{($slug): {http: $http, ssh: $ssh}}')

            {
              echo "tunnels_ok=true"
              echo "bore_host=bore.pub"
              echo "http_port=$HTTP_PORT"
              echo "ssh_port=$SSH_PORT"
              echo "tunnel_ports=$TUNNEL_PORTS"
            } >> "$GITHUB_OUTPUT"

            echo "Bore tunnels established successfully ‚úÖ"
            echo "  HTTP: bore.pub:$HTTP_PORT -> localhost:$LOCAL_HTTP"
            echo "  SSH:  bore.pub:$SSH_PORT -> localhost:$LOCAL_SSH"
            echo ""
            echo "Tunnel ports JSON: $TUNNEL_PORTS"
          else
            echo "::warning::Bore tunnels failed - falling back to localhost"
            {
              echo "tunnels_ok=false"
              echo "bore_host=localhost"
              echo "http_port=$LOCAL_HTTP"
              echo "ssh_port=$LOCAL_SSH"
              echo "tunnel_ports="
            } >> "$GITHUB_OUTPUT"

            if [ -z "$HTTP_PORT" ]; then
              echo "HTTP tunnel failed:"
              cat bore-http.log
            fi
            if [ -z "$SSH_PORT" ]; then
              echo "SSH tunnel failed:"
              cat bore-ssh.log
            fi
          fi

      # ================================================================
      # START GERRIT WITH TUNNEL URLS
      # ================================================================
      # Now we start Gerrit with the tunnel configuration passed in.
      # The action will configure canonicalWebUrl, sshd.advertisedAddress,
      # etc. with the public tunnel URLs from the start.
      # NO CONTAINER RESTART REQUIRED!
      # ================================================================

      - name: "Start Gerrit mirror"
        id: gerrit
        # yamllint disable-line rule:line-length
        uses: modeseven-lfreleng-actions/gerrit-action@refactor-replication  # Testing
        with:
          gerrit_setup: |
            [{
              "project": "${{ steps.server.outputs.project_filter }}",
              "slug": "${{ inputs.server_slug }}",
              "gerrit": "${{ steps.server.outputs.gerrit }}",
              "api_path": "${{ steps.server.outputs.api_path }}"
            }]
          auth_type: http_basic
          http_username: ${{ steps.credentials.outputs.username }}
          http_password: ${{ steps.credentials.outputs.password }}
          ssh_auth_keys: ${{ vars.GERRIT_PUBLIC_KEYS }}
          sync_on_startup: ${{ inputs.sync_on_startup }}
          use_api_path: ${{ inputs.use_api_path }}
          debug: "true"
          check_service: true
          exit: false
          # Pass tunnel config - Gerrit uses these URLs from the start
          # yamllint disable-line rule:line-length
          tunnel_host: ${{ steps.tunnels.outputs.tunnels_ok == 'true' && 'bore.pub' || '' }}
          tunnel_ports: ${{ steps.tunnels.outputs.tunnel_ports }}

      - name: "Verify tunnel connectivity"
        if: steps.tunnels.outputs.tunnels_ok == 'true'
        env:
          BORE_HOST: ${{ steps.tunnels.outputs.bore_host }}
          HTTP_PORT: ${{ steps.tunnels.outputs.http_port }}
          API_PATH: ${{ steps.server.outputs.api_path }}
          USE_API_PATH: ${{ inputs.use_api_path }}
        run: |
          # Verify the tunnel is working by hitting Gerrit through it
          echo "Verifying tunnel connectivity..."

          # Compute effective API path
          EFFECTIVE_API_PATH=""
          if [ "${USE_API_PATH:-false}" = "true" ] && [ -n "$API_PATH" ]; then
            EFFECTIVE_API_PATH="$API_PATH"
          fi

          # Build URL
          if [ -n "$EFFECTIVE_API_PATH" ]; then
            URL="http://${BORE_HOST}:${HTTP_PORT}${EFFECTIVE_API_PATH}/config/server/version"
          else
            URL="http://${BORE_HOST}:${HTTP_PORT}/config/server/version"
          fi

          echo "Testing: $URL"

          # Try a few times (tunnel might need a moment)
          MAX_ATTEMPTS=5
          for i in $(seq 1 $MAX_ATTEMPTS); do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            if echo "$HTTP_CODE" | grep -q "200"; then
              VERSION=$(curl -s "$URL" | tr -d '")' | tail -1)
              echo "Tunnel verified ‚úÖ (Gerrit $VERSION)"
              exit 0
            fi
            echo "  Attempt $i/$MAX_ATTEMPTS failed, retrying..."
            sleep 3
          done

          echo "::warning::Could not verify tunnel connectivity"
          echo "Gerrit may still be starting up"

      - name: "Display connection info"
        env:
          BORE_HOST: ${{ steps.tunnels.outputs.bore_host }}
          HTTP_PORT: ${{ steps.tunnels.outputs.http_port }}
          SSH_PORT: ${{ steps.tunnels.outputs.ssh_port }}
          LOCAL_HTTP: ${{ steps.tunnels.outputs.local_http_port }}
          LOCAL_SSH: ${{ steps.tunnels.outputs.local_ssh_port }}
          DEBUG_MINUTES: ${{ steps.validate.outputs.debug_minutes }}
          SERVER_NAME: ${{ steps.server.outputs.name }}
          API_PATH: ${{ steps.server.outputs.api_path }}
          SERVER_SLUG: ${{ inputs.server_slug }}
          USE_API_PATH: ${{ inputs.use_api_path }}
          TUNNELS_OK: ${{ steps.tunnels.outputs.tunnels_ok }}
        run: |
          # Display connection information
          # Build tunnel info array for iteration
          declare -a TUNNELS=()

          # Compute effective_api_path based on USE_API_PATH
          EFFECTIVE_API_PATH=""
          if [ "${USE_API_PATH:-false}" = "true" ] && [ -n "$API_PATH" ]; then
            EFFECTIVE_API_PATH="$API_PATH"
          fi

          # Build tunnel info - BORE_HOST is bore.pub or localhost
          if [ -n "$HTTP_PORT" ]; then
            if [ -n "$EFFECTIVE_API_PATH" ]; then
              HTTP_URL="http://${BORE_HOST}:${HTTP_PORT}${EFFECTIVE_API_PATH}/"
            else
              HTTP_URL="http://${BORE_HOST}:${HTTP_PORT}/"
            fi
            TUNNELS+=("http|Web UI|$LOCAL_HTTP|$HTTP_PORT|$HTTP_URL")
          fi
          if [ -n "$SSH_PORT" ]; then
            SSH_URL="ssh://admin@${BORE_HOST}:${SSH_PORT}"
            TUNNELS+=("ssh|SSH/Git|$LOCAL_SSH|$SSH_PORT|$SSH_URL")
          fi

          # Note access type
          if [ "$TUNNELS_OK" != "true" ]; then
            echo "::warning::Using localhost - not publicly accessible"
          fi

          {
            echo "# üîß Debug Session: $SERVER_NAME"
            echo ""
            echo "## üåê Public Access Ports"
            echo ""
            echo "| Service | Local Port | Public Port | Public URL |"
            echo "|---------|------------|-------------|------------|"

            for t in "${TUNNELS[@]}"; do
              IFS='|' read -r _ LABEL LOCAL PUBLIC URL <<< "$t"
              echo "| **$LABEL** | $LOCAL | $PUBLIC | \`$URL\` |"
            done

            if [ ${#TUNNELS[@]} -eq 0 ]; then
              echo "| ‚ùå No tunnels | - | - | - |"
            fi

            # Show access type notice
            if [ "$TUNNELS_OK" != "true" ]; then
              echo ""
              echo "> ‚ö†Ô∏è **Local access only** - bore tunnels unavailable"
            fi

            echo ""
            echo "## üîó Quick Access"
            echo ""

            if [ -n "$HTTP_PORT" ]; then
              echo "### Gerrit Web Portal"
              echo ""
              if [ -n "$EFFECTIVE_API_PATH" ]; then
                echo "**URL**: http://$BORE_HOST:$HTTP_PORT$EFFECTIVE_API_PATH/"
              else
                echo "**URL**: http://$BORE_HOST:$HTTP_PORT/"
              fi
              echo ""
              echo '```bash'
              echo "# Check version"
              if [ -n "$EFFECTIVE_API_PATH" ]; then
                URL="http://$BORE_HOST:$HTTP_PORT$EFFECTIVE_API_PATH"
              else
                URL="http://$BORE_HOST:$HTTP_PORT"
              fi
              echo "curl -s $URL/config/server/version"
              echo ""
              echo "# List projects"
              echo "curl -s $URL/projects/"
              echo '```'
              echo ""
            fi

            if [ -n "$SSH_PORT" ]; then
              echo "### SSH Access"
              echo ""
              echo '```bash'
              echo "# Test connection"
              echo "ssh -p $SSH_PORT admin@$BORE_HOST gerrit version"
              echo ""
              echo "# Clone a repository"
              echo "git clone ssh://admin@$BORE_HOST:$SSH_PORT/PROJECT_NAME"
              echo '```'
              echo ""
            fi

            echo "## ‚è±Ô∏è Session Info"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| Server | $SERVER_NAME (\`$SERVER_SLUG\`) |"
            echo "| Duration | $DEBUG_MINUTES minutes |"
            echo "| Startup Mode | Tunnel-first (no restart) |"
            DATE_FMT='+%Y-%m-%d %H:%M:%S %Z'
            EXPIRY=$(date -d "+$DEBUG_MINUTES minutes" "$DATE_FMT" \
              2>/dev/null || date -v+"${DEBUG_MINUTES}"M "$DATE_FMT")
            echo "| Expires | $EXPIRY |"
            echo ""
            if [ "$TUNNELS_OK" = "true" ]; then
              echo "> ‚ö†Ô∏è **Warning**: URLs are publicly accessible!"
            fi
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          # Console output
          echo ""
          echo "========================================"
          echo "  DEBUG SESSION ACTIVE"
          echo "========================================"
          for t in "${TUNNELS[@]}"; do
            IFS='|' read -r _ LABEL _ _ URL <<< "$t"
            printf "  %-10s %s\n" "$LABEL:" "$URL"
          done
          echo "  Duration:  $DEBUG_MINUTES minutes"
          echo "  Mode:      Tunnel-first (no restart)"
          echo "========================================"
          echo ""

      - name: "Keep session alive"
        env:
          DEBUG_MINUTES: ${{ steps.validate.outputs.debug_minutes }}
        run: |
          # Keep the session alive for the specified duration
          echo "Session will remain active for $DEBUG_MINUTES minutes..."
          echo "Cancel the workflow manually when you're done debugging."
          echo ""

          # Sleep with periodic status updates
          TOTAL_SECONDS=$((DEBUG_MINUTES * 60))
          ELAPSED=0
          INTERVAL=60

          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            REMAINING=$(( (TOTAL_SECONDS - ELAPSED) / 60 ))
            echo "[$(date '+%H:%M:%S')] $REMAINING minutes remaining..."

            # Check if tunnels are still running
            if ! pgrep -f "bore local" > /dev/null; then
              echo "::warning::bore tunnels have stopped unexpectedly"
              echo "HTTP tunnel log:"
              cat bore-http.log 2>/dev/null || echo "(no log)"
              echo "SSH tunnel log:"
              cat bore-ssh.log 2>/dev/null || echo "(no log)"
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "Debug session time expired."

      - name: "Cleanup"
        if: always()
        env:
          CONTAINER_IDS: ${{ steps.gerrit.outputs.container_ids }}
        run: |
          # Cleanup tunnels and containers
          echo "Cleaning up..."

          # Stop bore tunnels
          pkill -f "bore local" 2>/dev/null || true

          # Stop and remove Gerrit containers
          if [ -n "$CONTAINER_IDS" ]; then
            echo "$CONTAINER_IDS" | jq -r '.[]' 2>/dev/null | \
              while IFS= read -r cid; do
                [ -z "$cid" ] && continue
                echo "Stopping container: $cid"
                docker kill "$cid" 2>/dev/null || true
                echo "Removing container: $cid"
                docker rm "$cid" 2>/dev/null || true
              done
          fi

          echo "Cleanup complete ‚úÖ"
