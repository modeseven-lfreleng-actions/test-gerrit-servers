---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# Debug Gerrit with remote access via bore tunnel
name: "Debug Gerrit (bore tunnel) üîß"

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
    inputs:
      server_slug:
        description: "Gerrit server to debug (from GERRIT_SERVERS)"
        required: true
        default: "onap"
        type: string
      debug_minutes:
        description: "Minutes to keep tunnel open (max 60)"
        required: false
        default: 15
        type: number
      sync_on_startup:
        description: "Trigger replication after startup"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"

concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: true

permissions: {}

jobs:
  debug-gerrit:
    name: "Debug Gerrit via bore tunnel"
    runs-on: ubuntu-latest
    timeout-minutes: 65
    permissions:
      contents: read
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: "Validate inputs"
        id: validate
        env:
          DEBUG_MINUTES: ${{ inputs.debug_minutes || 30 }}
        run: |
          # Validate debug_minutes input
          if ! [[ "$DEBUG_MINUTES" =~ ^[0-9]+$ ]]; then
            echo "::error::debug_minutes must be an integer: $DEBUG_MINUTES"
            exit 1
          fi
          if [ "$DEBUG_MINUTES" -gt 60 ]; then
            echo "::warning::debug_minutes capped at 60 (was: $DEBUG_MINUTES)"
            DEBUG_MINUTES=60
          fi
          if [ "$DEBUG_MINUTES" -lt 5 ]; then
            echo "::warning::debug_minutes minimum is 5 (was: $DEBUG_MINUTES)"
            DEBUG_MINUTES=5
          fi
          echo "debug_minutes=$DEBUG_MINUTES" >> "$GITHUB_OUTPUT"
          echo "Validated debug_minutes: $DEBUG_MINUTES"

      - name: "Checkout repository"
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: "Lookup server config"
        id: server
        env:
          GERRIT_SERVERS: ${{ vars.GERRIT_SERVERS }}
          SERVER_SLUG: ${{ inputs.server_slug }}
        run: |
          # Lookup server configuration from GERRIT_SERVERS variable
          if [ -z "$GERRIT_SERVERS" ]; then
            echo "::error::GERRIT_SERVERS variable is not set"
            exit 1
          fi

          SERVER=$(echo "$GERRIT_SERVERS" | \
            jq -r --arg slug "$SERVER_SLUG" '.[] | select(.slug == $slug)')

          if [ -z "$SERVER" ]; then
            echo "::error::No server found for slug: $SERVER_SLUG"
            echo "Available slugs:"
            echo "$GERRIT_SERVERS" | jq -r '.[].slug'
            exit 1
          fi

          # Extract server details
          # shellcheck disable=SC2129
          echo "name=$(echo "$SERVER" | jq -r '.name')" >> "$GITHUB_OUTPUT"
          echo "gerrit=$(echo "$SERVER" | jq -r '.gerrit')" >> "$GITHUB_OUTPUT"
          API_PATH=$(echo "$SERVER" | jq -r '.api_path')
          echo "api_path=$API_PATH" >> "$GITHUB_OUTPUT"
          PROJECT_FILTER=$(echo "$SERVER" | jq -r '.project_filter // ""')
          echo "project_filter=$PROJECT_FILTER" >> "$GITHUB_OUTPUT"

          echo "Server: $(echo "$SERVER" | jq -r '.name')"
          echo "Gerrit: $(echo "$SERVER" | jq -r '.gerrit')"

      - name: "Lookup credentials"
        id: credentials
        env:
          GERRIT_CREDENTIALS_B64: ${{ secrets.GERRIT_CREDENTIALS }}
          SERVER_SLUG: ${{ inputs.server_slug }}
        run: |
          # Lookup credentials for this server
          if [ -z "$GERRIT_CREDENTIALS_B64" ]; then
            echo "::error::GERRIT_CREDENTIALS secret is not set"
            exit 1
          fi

          GERRIT_CREDENTIALS=$(echo "$GERRIT_CREDENTIALS_B64" \
            | base64 -d 2>/dev/null)
          if [ -z "$GERRIT_CREDENTIALS" ]; then
            echo "::error::Failed to decode GERRIT_CREDENTIALS"
            exit 1
          fi

          CREDS=$(echo "$GERRIT_CREDENTIALS" | \
            jq -r --arg slug "$SERVER_SLUG" '.[] | select(.slug == $slug)')

          if [ -z "$CREDS" ]; then
            echo "::error::No credentials found for slug: $SERVER_SLUG"
            exit 1
          fi

          USERNAME=$(echo "$CREDS" | jq -r '.username')
          PASSWORD=$(echo "$CREDS" | jq -r '.password')
          echo "::add-mask::$PASSWORD"
          echo "username=$USERNAME" >> "$GITHUB_OUTPUT"
          echo "password=$PASSWORD" >> "$GITHUB_OUTPUT"

      - name: "Start Gerrit mirror"
        id: gerrit
        # yamllint disable-line rule:line-length
        uses: modeseven-lfreleng-actions/gerrit-action@refactor-replication  # Testing
        with:
          gerrit_setup: |
            [{
              "project": "${{ steps.server.outputs.project_filter }}",
              "slug": "${{ inputs.server_slug }}",
              "gerrit": "${{ steps.server.outputs.gerrit }}",
              "api_path": "${{ steps.server.outputs.api_path }}"
            }]
          auth_type: http_basic
          http_username: ${{ steps.credentials.outputs.username }}
          http_password: ${{ steps.credentials.outputs.password }}
          ssh_auth_keys: ${{ vars.GERRIT_PUBLIC_KEYS }}
          sync_on_startup: ${{ inputs.sync_on_startup }}
          debug: "true"
          check_service: true
          exit: false

      - name: "Install bore"
        run: |
          # Install bore TCP tunnel client
          BORE_VERSION="0.5.2"
          BORE_URL="https://github.com/ekzhang/bore/releases/download"
          BORE_FILE="bore-v${BORE_VERSION}-x86_64-unknown-linux-musl.tar.gz"

          echo "Downloading bore v${BORE_VERSION}..."
          curl -sSL "${BORE_URL}/v${BORE_VERSION}/${BORE_FILE}" | tar xz

          # Verify installation
          ./bore --version
          sudo mv bore /usr/local/bin/
          echo "bore installed successfully ‚úÖ"

      - name: "Start bore tunnels"
        id: tunnels
        env:
          INSTANCES: ${{ steps.gerrit.outputs.instances }}
          SERVER_SLUG: ${{ inputs.server_slug }}
          API_PATH: ${{ steps.server.outputs.api_path }}
        run: |
          # Start bore tunnels for HTTP and SSH ports
          # Uses dynamic ports from gerrit-action outputs
          echo "Starting bore tunnels to bore.pub..."

          # Extract ports from gerrit-action instances output
          LOCAL_HTTP=$(echo "$INSTANCES" | \
            jq -r --arg s "$SERVER_SLUG" '.[$s].http_port // 8080')
          LOCAL_SSH=$(echo "$INSTANCES" | \
            jq -r --arg s "$SERVER_SLUG" '.[$s].ssh_port // 29418')

          echo "local_http_port=$LOCAL_HTTP" >> "$GITHUB_OUTPUT"
          echo "local_ssh_port=$LOCAL_SSH" >> "$GITHUB_OUTPUT"

          # Start HTTP tunnel
          bore local "$LOCAL_HTTP" --to bore.pub > bore-http.log 2>&1 &
          echo "http_pid=$!" >> "$GITHUB_OUTPUT"

          # Start SSH tunnel
          bore local "$LOCAL_SSH" --to bore.pub > bore-ssh.log 2>&1 &
          echo "ssh_pid=$!" >> "$GITHUB_OUTPUT"

          # Wait for tunnels to establish
          echo "Waiting for tunnels to establish..."
          sleep 10

          # Extract assigned ports from logs
          HTTP_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
            bore-http.log || echo "")
          SSH_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
            bore-ssh.log || echo "")

          if [ -z "$HTTP_PORT" ]; then
            echo "::warning::Could not determine HTTP tunnel port"
            cat bore-http.log
          else
            echo "http_port=$HTTP_PORT" >> "$GITHUB_OUTPUT"
            echo "HTTP: bore.pub:$HTTP_PORT -> localhost:$LOCAL_HTTP"
          fi

          if [ -z "$SSH_PORT" ]; then
            echo "::warning::Could not determine SSH tunnel port"
            cat bore-ssh.log
          else
            echo "ssh_port=$SSH_PORT" >> "$GITHUB_OUTPUT"
            echo "SSH: bore.pub:$SSH_PORT -> localhost:$LOCAL_SSH"
          fi

      - name: "Update Gerrit URLs for bore tunnels"
        env:
          INSTANCES: ${{ steps.gerrit.outputs.instances }}
          SERVER_SLUG: ${{ inputs.server_slug }}
          HTTP_PORT: ${{ steps.tunnels.outputs.http_port }}
          SSH_PORT: ${{ steps.tunnels.outputs.ssh_port }}
          API_PATH: ${{ steps.server.outputs.api_path }}
        run: |
          # Update Gerrit's URLs so clone commands show bore addresses
          CID=$(echo "$INSTANCES" | \
            jq -r --arg s "$SERVER_SLUG" '.[$s].cid')

          if [ -z "$CID" ] || [ "$CID" = "null" ]; then
            echo "::warning::Container not found, skipping URL update"
            exit 0
          fi

          CONFIG="/var/gerrit/etc/gerrit.config"

          # Update HTTP canonical URL
          if [ -n "$HTTP_PORT" ]; then
            NEW_URL="http://bore.pub:${HTTP_PORT}${API_PATH}"
            echo "Setting canonicalWebUrl: $NEW_URL"
            docker exec "$CID" git config -f "$CONFIG" \
              gerrit.canonicalWebUrl "$NEW_URL"
          fi

          # Update SSH advertised address
          if [ -n "$SSH_PORT" ]; then
            SSH_ADDR="bore.pub:${SSH_PORT}"
            echo "Setting sshd.advertisedAddress: $SSH_ADDR"
            docker exec "$CID" git config -f "$CONFIG" \
              sshd.advertisedAddress "$SSH_ADDR"
          fi

          # Flush caches to pick up the changes
          echo "Flushing Gerrit caches..."
          docker exec "$CID" bash -c '
            ssh -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=/dev/null \
                -p 29418 admin@localhost \
                gerrit flush-caches --all 2>/dev/null || true
          ' || true

          echo "Gerrit URLs updated for bore tunnels ‚úÖ"

      - name: "Display connection info"
        env:
          HTTP_PORT: ${{ steps.tunnels.outputs.http_port }}
          SSH_PORT: ${{ steps.tunnels.outputs.ssh_port }}
          LOCAL_HTTP: ${{ steps.tunnels.outputs.local_http_port }}
          LOCAL_SSH: ${{ steps.tunnels.outputs.local_ssh_port }}
          DEBUG_MINUTES: ${{ steps.validate.outputs.debug_minutes }}
          SERVER_NAME: ${{ steps.server.outputs.name }}
          API_PATH: ${{ steps.server.outputs.api_path }}
          SERVER_SLUG: ${{ inputs.server_slug }}
        run: |
          # Display connection information
          # Build tunnel info array for iteration
          declare -a TUNNELS=()

          if [ -n "$HTTP_PORT" ]; then
            HTTP_URL="http://bore.pub:${HTTP_PORT}${API_PATH}"
            TUNNELS+=("http|Web UI|$LOCAL_HTTP|$HTTP_PORT|$HTTP_URL")
          fi
          if [ -n "$SSH_PORT" ]; then
            TUNNELS+=("ssh|SSH/Git|$LOCAL_SSH|$SSH_PORT|ssh://admin@bore.pub:${SSH_PORT}")
          fi

          {
            echo "# üîß Debug Session: $SERVER_NAME"
            echo ""
            echo "## üåê Public Access Ports"
            echo ""
            echo "| Service | Local Port | Public Port | Public URL |"
            echo "|---------|------------|-------------|------------|"

            for t in "${TUNNELS[@]}"; do
              IFS='|' read -r _ LABEL LOCAL PUBLIC URL <<< "$t"
              echo "| **$LABEL** | $LOCAL | $PUBLIC | \`$URL\` |"
            done

            if [ ${#TUNNELS[@]} -eq 0 ]; then
              echo "| ‚ùå No tunnels | - | - | - |"
            fi

            echo ""
            echo "## üîó Quick Access"
            echo ""

            if [ -n "$HTTP_PORT" ]; then
              echo "### Gerrit Web Portal"
              echo ""
              echo "**URL**: http://bore.pub:$HTTP_PORT$API_PATH"
              echo ""
              echo '```bash'
              echo "# Check version"
              URL="http://bore.pub:$HTTP_PORT$API_PATH"
              echo "curl -s $URL/config/server/version"
              echo ""
              echo "# List projects"
              echo "curl -s http://bore.pub:$HTTP_PORT$API_PATH/projects/"
              echo '```'
              echo ""
            fi

            if [ -n "$SSH_PORT" ]; then
              echo "### SSH Access"
              echo ""
              echo '```bash'
              echo "# Test connection"
              echo "ssh -p $SSH_PORT admin@bore.pub gerrit version"
              echo ""
              echo "# Clone a repository"
              echo "git clone ssh://admin@bore.pub:$SSH_PORT/PROJECT_NAME"
              echo '```'
              echo ""
            fi

            echo "## ‚è±Ô∏è Session Info"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| Server | $SERVER_NAME (\`$SERVER_SLUG\`) |"
            echo "| Duration | $DEBUG_MINUTES minutes |"
            DATE_FMT='+%Y-%m-%d %H:%M:%S %Z'
            EXPIRY=$(date -d "+$DEBUG_MINUTES minutes" "$DATE_FMT" \
              2>/dev/null || date -v+"${DEBUG_MINUTES}"M "$DATE_FMT")
            echo "| Expires | $EXPIRY |"
            echo ""
            echo "> ‚ö†Ô∏è **Warning**: URLs are publicly accessible!"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          # Console output
          echo ""
          echo "========================================"
          echo "  DEBUG SESSION ACTIVE"
          echo "========================================"
          for t in "${TUNNELS[@]}"; do
            IFS='|' read -r _ LABEL _ _ URL <<< "$t"
            printf "  %-10s %s\n" "$LABEL:" "$URL"
          done
          echo "  Duration:  $DEBUG_MINUTES minutes"
          echo "========================================"
          echo ""

      - name: "Keep session alive"
        env:
          DEBUG_MINUTES: ${{ steps.validate.outputs.debug_minutes }}
        run: |
          # Keep the session alive for the specified duration
          echo "Session will remain active for $DEBUG_MINUTES minutes..."
          echo "Cancel the workflow manually when you're done debugging."
          echo ""

          # Sleep with periodic status updates
          TOTAL_SECONDS=$((DEBUG_MINUTES * 60))
          ELAPSED=0
          INTERVAL=60

          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            REMAINING=$(( (TOTAL_SECONDS - ELAPSED) / 60 ))
            echo "[$(date '+%H:%M:%S')] $REMAINING minutes remaining..."

            # Check if tunnels are still running
            if ! pgrep -f "bore local" > /dev/null; then
              echo "::warning::bore tunnels have stopped unexpectedly"
              echo "HTTP tunnel log:"
              cat bore-http.log 2>/dev/null || echo "(no log)"
              echo "SSH tunnel log:"
              cat bore-ssh.log 2>/dev/null || echo "(no log)"
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "Debug session time expired."

      - name: "Cleanup"
        if: always()
        env:
          CONTAINER_IDS: ${{ steps.gerrit.outputs.container_ids }}
        run: |
          # Cleanup tunnels and containers
          echo "Cleaning up..."

          # Stop bore tunnels
          pkill -f "bore local" 2>/dev/null || true

          # Stop Gerrit containers
          if [ -n "$CONTAINER_IDS" ]; then
            while IFS= read -r cid; do
              [ -z "$cid" ] && continue
              echo "Stopping container: $cid"
              docker kill "$cid" 2>/dev/null || true
            done < <(echo "$CONTAINER_IDS" | jq -r '.[]' 2>/dev/null)
          fi

          echo "Cleanup complete ‚úÖ"
