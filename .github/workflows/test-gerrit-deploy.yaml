---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# Test Gerrit server connectivity workflow
name: "Test Deploy Gerrit üîó"

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
    inputs:
      debug:
        description: "Enable debug output"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"
      sync_on_startup:
        description: "Trigger replication after startup"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      slug_selector:
        # Supports: 'all', single value, comma/space-separated, wildcards (*,?)
        description: "Server slug selector"
        required: false
        default: "all"
        type: string
      debug_minutes:
        description: "Minutes to keep debug session open (max 60)"
        required: false
        default: 15
        type: number
      use_api_path:
        # e.g., /r, /infra
        description: "Match origin server URL API path"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"
      enable_tunnel:
        description: "Enable tunnel for remote access"
        required: false
        default: true
        type: boolean
      resync_orgs:
        description: "Resync GitHub ORGs with Gerrit"
        required: false
        default: false
        type: boolean
      github_selector:
        # Supports: 'all', single value, comma/space-separated, wildcards (*,?)
        description: "GitHub org selector"
        required: false
        default: "all"
        type: string

concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: true

permissions: {}

jobs:
  ### Validate inputs ###
  validate:
    name: "Validate inputs"
    runs-on: ubuntu-latest
    timeout-minutes: 1
    permissions:
      contents: read
    outputs:
      debug_minutes: ${{ steps.validate.outputs.debug_minutes }}
      effective_debug: ${{ steps.validate.outputs.effective_debug }}
    steps:
      - name: "Validate debug_minutes"
        id: validate
        env:
          DEBUG_MINUTES: ${{ inputs.debug_minutes || 15 }}
          DEBUG_INPUT: ${{ inputs.debug || 'false' }}
          # RUNNER_DEBUG is set to '1' when re-running with debug logging
          RUNNER_DEBUG: ${{ runner.debug }}
          # ACTIONS_STEP_DEBUG is 'true' when step debug logging is enabled
          ACTIONS_STEP_DEBUG: ${{ secrets.ACTIONS_STEP_DEBUG }}
        run: |
          # Validate debug_minutes input
          if ! [[ "$DEBUG_MINUTES" =~ ^[0-9]+$ ]]; then
            echo "::error::debug_minutes must be an integer: $DEBUG_MINUTES"
            exit 1
          fi
          if [ "$DEBUG_MINUTES" -gt 60 ]; then
            echo "::warning::debug_minutes capped at 60 (was: $DEBUG_MINUTES)"
            DEBUG_MINUTES=60
          fi
          if [ "$DEBUG_MINUTES" -lt 5 ]; then
            echo "::warning::debug_minutes minimum is 5 (was: $DEBUG_MINUTES)"
            DEBUG_MINUTES=5
          fi
          echo "debug_minutes=$DEBUG_MINUTES" >> "$GITHUB_OUTPUT"
          echo "Validated debug_minutes: $DEBUG_MINUTES"

          # Compute effective debug: true if input OR runner debug is enabled
          # GitHub sets RUNNER_DEBUG=1 and/or ACTIONS_STEP_DEBUG=true when
          # re-running with debug logging enabled
          if [ "$DEBUG_INPUT" = "true" ] || [ "$RUNNER_DEBUG" = "1" ] || \
             [ "$ACTIONS_STEP_DEBUG" = "true" ]; then
            EFFECTIVE_DEBUG="true"
            if [ "$RUNNER_DEBUG" = "1" ] || \
               [ "$ACTIONS_STEP_DEBUG" = "true" ]; then
              echo "Debug enabled via GitHub 'Re-run with debug logging'"
              echo "  RUNNER_DEBUG=$RUNNER_DEBUG"
              echo "  ACTIONS_STEP_DEBUG=$ACTIONS_STEP_DEBUG"
            else
              echo "Debug enabled via workflow input"
            fi
          else
            EFFECTIVE_DEBUG="false"
          fi
          echo "effective_debug=$EFFECTIVE_DEBUG" >> "$GITHUB_OUTPUT"
          echo "Effective debug: $EFFECTIVE_DEBUG"

  ### Extract non-sensitive matrix data ###
  prepare:
    name: "Prepare Gerrit matrix"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      debug_matrix: ${{ steps.set-matrix.outputs.debug_matrix }}
      debug_count: ${{ steps.set-matrix.outputs.debug_count }}
    steps:
      # Harden the runner used by this workflow
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9  # v2.14.1
        with:
          egress-policy: audit

      - name: "Set matrix from repository variable"
        id: set-matrix
        env:
          # GERRIT_SERVERS is a repository variable (not secret) containing:
          # [{"project":"ONAP","slug":"onap","gerrit":"gerrit.onap.org",...}]
          GERRIT_SERVERS: ${{ vars.GERRIT_SERVERS }}
          SLUG_SELECTOR: ${{ inputs.slug_selector }}
        run: |
          # Set matrix from GERRIT_SERVERS repository variable
          if [ -z "$GERRIT_SERVERS" ]; then
            echo "::error::GERRIT_SERVERS variable is not set"
            exit 1
          fi

          # Validate JSON format
          if ! echo "$GERRIT_SERVERS" | jq empty 2>/dev/null; then
            echo "::error::GERRIT_SERVERS is not valid JSON"
            exit 1
          fi

          # Output full matrix for sync tests
          MATRIX=$(echo "$GERRIT_SERVERS" | jq -c '.')
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          COUNT=$(echo "$GERRIT_SERVERS" | jq '. | length')
          echo "Full matrix prepared with $COUNT Gerrit servers"

          # Output filtered matrix for debug tests
          if [ -z "$SLUG_SELECTOR" ] || [ "$SLUG_SELECTOR" = "all" ]; then
            # Empty selector or "all" = all servers
            DEBUG_MATRIX="$MATRIX"
            echo "Debug matrix: all $COUNT servers (no selector)"
          else
            # Parse comma/space-separated selectors and support wildcards
            # Convert to newline-separated, trim whitespace
            SELECTORS=$(echo "$SLUG_SELECTOR" | tr ',' '\n' | tr ' ' '\n' | \
              sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$')

            echo "Selectors to match:"
            echo "$SELECTORS"

            # Build jq filter for each selector (wildcards supported)
            # Convert shell wildcards to regex: * -> .*, ? -> .
            DEBUG_MATRIX=$(echo "$GERRIT_SERVERS" | \
              jq -c --arg selectors "$SELECTORS" '
              ($selectors | split("\n")) as $sels |
              [.[] | . as $server |
                select(
                  any($sels[]; . as $sel |
                    if ($sel | contains("*")) or ($sel | contains("?")) then
                      # Convert glob to regex: * -> .*, ? -> .
                      ($sel | gsub("\\*"; ".*") | gsub("\\?"; ".")) as $regex |
                      ($server.slug | test("^" + $regex + "$"))
                    else
                      $server.slug == $sel
                    end
                  )
                )
              ]
            ')
            DEBUG_COUNT=$(echo "$DEBUG_MATRIX" | jq '. | length')
            if [ "$DEBUG_COUNT" -eq 0 ]; then
              echo "::error::No servers matched selector: $SLUG_SELECTOR"
              echo "Available slugs:"
              echo "$GERRIT_SERVERS" | jq -r '.[].slug'
              exit 1
            fi
            echo "Debug matrix: $DEBUG_COUNT server(s) [$SLUG_SELECTOR]"
          fi
          echo "debug_matrix=$DEBUG_MATRIX" >> "$GITHUB_OUTPUT"
          DEBUG_COUNT=$(echo "$DEBUG_MATRIX" | jq '. | length')
          echo "debug_count=$DEBUG_COUNT" >> "$GITHUB_OUTPUT"

  ### Test Gerrit server startup and sync ###
  sync-test:
    name: "${{ matrix.server.name }}"
    runs-on: ubuntu-latest
    needs: [validate, prepare]
    permissions:
      contents: read
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        server: ${{ fromJSON(needs.prepare.outputs.matrix) }}
    steps:
      # Harden the runner used by this workflow
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9  # v2.14.1
        with:
          egress-policy: audit

      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: "Lookup credentials for ${{ matrix.server.slug }}"
        id: credentials
        env:
          GERRIT_CREDENTIALS_B64: ${{ secrets.GERRIT_CREDENTIALS }}
          SERVER_SLUG: ${{ matrix.server.slug }}
        run: |
          # Lookup credentials for this server from the base64-encoded secret
          if [ -z "$GERRIT_CREDENTIALS_B64" ]; then
            echo "::error::GERRIT_CREDENTIALS secret is not set"
            exit 1
          fi

          # Decode base64-encoded credentials JSON
          # The secret is stored as base64 to avoid GitHub's spurious redactions
          GERRIT_CREDENTIALS=$(echo "$GERRIT_CREDENTIALS_B64" \
            | base64 -d 2>/dev/null)
          if [ -z "$GERRIT_CREDENTIALS" ]; then
            echo "::error::Failed to decode GERRIT_CREDENTIALS (invalid base64)"
            exit 1
          fi

          # Validate JSON format
          if ! echo "$GERRIT_CREDENTIALS" | jq empty 2>/dev/null; then
            echo "::error::Decoded GERRIT_CREDENTIALS is not valid JSON"
            exit 1
          fi

          CREDS=$(echo "$GERRIT_CREDENTIALS" | \
            jq -r --arg slug "$SERVER_SLUG" '.[] | select(.slug == $slug)')

          if [ -z "$CREDS" ]; then
            echo "::error::No credentials found for slug: $SERVER_SLUG"
            exit 1
          fi

          # Extract and mask sensitive values
          USERNAME=$(echo "$CREDS" | jq -r '.username')
          PASSWORD=$(echo "$CREDS" | jq -r '.password')

          # Mask the password in logs
          echo "::add-mask::$PASSWORD"

          # Set outputs for use in subsequent steps
          echo "username=$USERNAME" >> "$GITHUB_OUTPUT"
          echo "password=$PASSWORD" >> "$GITHUB_OUTPUT"

      - name: "Test Gerrit server: ${{ matrix.server.gerrit }}"
        id: gerrit
        # yamllint disable-line rule:line-length
        uses: modeseven-lfreleng-actions/gerrit-action@refactor-replication  # Testing
        with:
          gerrit_setup: |
            [{
              "project": "${{ matrix.server.project_filter || '' }}",
              "slug": "${{ matrix.server.slug }}",
              "gerrit": "${{ matrix.server.gerrit }}",
              "api_path": "${{ matrix.server.api_path }}"
            }]
          auth_type: http_basic
          http_username: ${{ steps.credentials.outputs.username }}
          http_password: ${{ steps.credentials.outputs.password }}
          sync_on_startup: ${{ inputs.sync_on_startup || 'false' }}
          debug: ${{ needs.validate.outputs.effective_debug }}
          check_service: true
          exit: true

      - name: "Report success: ${{ matrix.server.name }}"
        env:
          API_PATHS: ${{ steps.gerrit.outputs.api_paths }}
        run: |
          # Report success
          {
            echo "## ‚úÖ ${{ matrix.server.name }}"
            echo ""
            echo "Successfully connected to \`${{ matrix.server.gerrit }}\`"
            echo ""
            echo "### API Path Information"
            echo '```json'
            echo "$API_PATHS" | jq '.'
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

  ### Debug Gerrit Deployment with Optional Tunnel Access ###
  persist-gerrit:
    name: "Persist: ${{ matrix.server.name }}"
    runs-on: ubuntu-latest
    needs: [validate, prepare]
    if: needs.validate.outputs.debug_minutes != '0'
    permissions:
      contents: read
    timeout-minutes: 65
    strategy:
      fail-fast: false
      matrix:
        server: ${{ fromJSON(needs.prepare.outputs.debug_matrix) }}
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9  # v2.14.1
        with:
          egress-policy: audit

      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: "Lookup credentials for ${{ matrix.server.slug }}"
        id: credentials
        env:
          GERRIT_CREDENTIALS_B64: ${{ secrets.GERRIT_CREDENTIALS }}
          SERVER_SLUG: ${{ matrix.server.slug }}
        run: |
          # Lookup credentials for this server from the base64-encoded secret
          if [ -z "$GERRIT_CREDENTIALS_B64" ]; then
            echo "::error::GERRIT_CREDENTIALS secret is not set"
            exit 1
          fi

          GERRIT_CREDENTIALS=$(echo "$GERRIT_CREDENTIALS_B64" \
            | base64 -d 2>/dev/null)
          if [ -z "$GERRIT_CREDENTIALS" ]; then
            echo "::error::Failed to decode GERRIT_CREDENTIALS (invalid base64)"
            exit 1
          fi

          if ! echo "$GERRIT_CREDENTIALS" | jq empty 2>/dev/null; then
            echo "::error::Decoded GERRIT_CREDENTIALS is not valid JSON"
            exit 1
          fi

          CREDS=$(echo "$GERRIT_CREDENTIALS" | \
            jq -r --arg slug "$SERVER_SLUG" '.[] | select(.slug == $slug)')

          if [ -z "$CREDS" ]; then
            echo "::error::No credentials found for slug: $SERVER_SLUG"
            exit 1
          fi

          USERNAME=$(echo "$CREDS" | jq -r '.username')
          PASSWORD=$(echo "$CREDS" | jq -r '.password')
          echo "::add-mask::$PASSWORD"
          echo "username=$USERNAME" >> "$GITHUB_OUTPUT"
          echo "password=$PASSWORD" >> "$GITHUB_OUTPUT"

      # ================================================================
      # TUNNEL SETUP (optional, before Gerrit)
      # ================================================================

      - name: "Calculate local ports"
        id: ports
        if: inputs.enable_tunnel
        env:
          SERVER_SLUG: ${{ matrix.server.slug }}
          DEBUG_MATRIX: ${{ needs.prepare.outputs.debug_matrix }}
        run: |
          # Calculate deterministic local ports
          # These match what gerrit-action will use (BASE_PORT + index)
          BASE_HTTP_PORT=8080
          BASE_SSH_PORT=29418

          # Find index of this server in the debug matrix
          INDEX=$(echo "$DEBUG_MATRIX" | jq -r --arg slug "$SERVER_SLUG" \
            'to_entries | .[] | select(.value.slug == $slug) | .key')
          INDEX=${INDEX:-0}

          HTTP_PORT=$((BASE_HTTP_PORT + INDEX))
          SSH_PORT=$((BASE_SSH_PORT + INDEX))

          {
            echo "http_port=$HTTP_PORT"
            echo "ssh_port=$SSH_PORT"
            echo "index=$INDEX"
          } >> "$GITHUB_OUTPUT"

          echo "Local ports calculated (index $INDEX):"
          echo "  HTTP: $HTTP_PORT"
          echo "  SSH:  $SSH_PORT"

      - name: "Install bore"
        if: inputs.enable_tunnel
        run: |
          # Install bore TCP tunnel client
          BORE_VERSION="0.5.2"
          BORE_URL="https://github.com/ekzhang/bore/releases/download"
          BORE_FILE="bore-v${BORE_VERSION}-x86_64-unknown-linux-musl.tar.gz"

          echo "Downloading bore v${BORE_VERSION}..."
          curl -sSL "${BORE_URL}/v${BORE_VERSION}/${BORE_FILE}" | tar xz

          ./bore --version
          sudo mv bore /usr/local/bin/
          echo "bore installed successfully ‚úÖ"

      - name: "Start bore tunnels"
        id: tunnels
        if: inputs.enable_tunnel
        env:
          LOCAL_HTTP: ${{ steps.ports.outputs.http_port }}
          LOCAL_SSH: ${{ steps.ports.outputs.ssh_port }}
          SERVER_SLUG: ${{ matrix.server.slug }}
        run: |
          # Start bore tunnels BEFORE Gerrit container
          echo "Starting bore tunnels to bore.pub..."

          # Start HTTP tunnel
          bore local "$LOCAL_HTTP" --to bore.pub > bore-http.log 2>&1 &
          HTTP_PID=$!

          # Start SSH tunnel
          bore local "$LOCAL_SSH" --to bore.pub > bore-ssh.log 2>&1 &
          SSH_PID=$!

          {
            echo "http_pid=$HTTP_PID"
            echo "ssh_pid=$SSH_PID"
            echo "local_http_port=$LOCAL_HTTP"
            echo "local_ssh_port=$LOCAL_SSH"
          } >> "$GITHUB_OUTPUT"

          # Wait for tunnels to establish
          echo "Waiting for tunnels to establish..."
          MAX_WAIT=30
          WAIT_INTERVAL=2
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))

            HTTP_RUNNING=true
            SSH_RUNNING=true
            if ! kill -0 "$HTTP_PID" 2>/dev/null; then
              HTTP_RUNNING=false
            fi
            if ! kill -0 "$SSH_PID" 2>/dev/null; then
              SSH_RUNNING=false
            fi

            HTTP_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
              bore-http.log 2>/dev/null || echo "")
            SSH_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
              bore-ssh.log 2>/dev/null || echo "")

            if [ -n "$HTTP_PORT" ] && [ -n "$SSH_PORT" ]; then
              echo "Tunnels established after ${ELAPSED}s"
              break
            fi

            if [ "$HTTP_RUNNING" = "false" ] && [ -z "$HTTP_PORT" ]; then
              echo "HTTP tunnel process exited unexpectedly"
              break
            fi
            if [ "$SSH_RUNNING" = "false" ] && [ -z "$SSH_PORT" ]; then
              echo "SSH tunnel process exited unexpectedly"
              break
            fi

            echo "  Waiting... (${ELAPSED}s/${MAX_WAIT}s)"
          done

          # Final port extraction
          HTTP_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
            bore-http.log 2>/dev/null || echo "")
          SSH_PORT=$(grep -oP 'listening at bore\.pub:\K\d+' \
            bore-ssh.log 2>/dev/null || echo "")

          if [ -n "$HTTP_PORT" ] && [ -n "$SSH_PORT" ]; then
            TUNNEL_PORTS=$(jq -n \
              --arg slug "$SERVER_SLUG" \
              --argjson http "$HTTP_PORT" \
              --argjson ssh "$SSH_PORT" \
              '{($slug): {http: $http, ssh: $ssh}}')

            {
              echo "tunnels_ok=true"
              echo "bore_host=bore.pub"
              echo "http_port=$HTTP_PORT"
              echo "ssh_port=$SSH_PORT"
              echo "tunnel_ports=$TUNNEL_PORTS"
            } >> "$GITHUB_OUTPUT"

            echo "Bore tunnels established successfully ‚úÖ"
            echo "  HTTP: bore.pub:$HTTP_PORT -> localhost:$LOCAL_HTTP"
            echo "  SSH:  bore.pub:$SSH_PORT -> localhost:$LOCAL_SSH"
          else
            HTTP_ERR=$(head -1 bore-http.log 2>/dev/null || echo "unknown")
            SSH_ERR=$(head -1 bore-ssh.log 2>/dev/null || echo "unknown")

            echo ""
            echo "‚ùå Bore tunnel setup failed"
            if [ "$HTTP_ERR" = "$SSH_ERR" ]; then
              echo "  Error: $HTTP_ERR"
            else
              [ -z "$HTTP_PORT" ] && echo "  HTTP: $HTTP_ERR"
              [ -z "$SSH_PORT" ] && echo "  SSH: $SSH_ERR"
            fi

            {
              echo "## ‚ùå Bore Tunnel Setup Failed"
              echo ""
              if [ "$HTTP_ERR" = "$SSH_ERR" ]; then
                echo "$HTTP_ERR"
              else
                [ -z "$HTTP_PORT" ] && echo "- **HTTP:** $HTTP_ERR"
                [ -z "$SSH_PORT" ] && echo "- **SSH:** $SSH_ERR"
              fi
              echo ""
              echo "bore.pub may be down, or port 7835 is blocked."
            } >> "$GITHUB_STEP_SUMMARY"

            echo "::error::Bore tunnel setup failed. Check job summary."
            exit 1
          fi

      # ================================================================
      # START GERRIT
      # ================================================================

      - name: "Start Gerrit mirror: ${{ matrix.server.name }}"
        id: gerrit
        # yamllint disable-line rule:line-length
        uses: modeseven-lfreleng-actions/gerrit-action@refactor-replication  # Testing
        with:
          gerrit_setup: |
            [{
              "project": "${{ matrix.server.project_filter || '' }}",
              "slug": "${{ matrix.server.slug }}",
              "gerrit": "${{ matrix.server.gerrit }}",
              "api_path": "${{ matrix.server.api_path }}"
            }]
          auth_type: http_basic
          http_username: ${{ steps.credentials.outputs.username }}
          http_password: ${{ steps.credentials.outputs.password }}
          ssh_auth_keys: ${{ vars.GERRIT_PUBLIC_KEYS }}
          ssh_auth_username: 'modesevenindustrialsolutions'
          sync_on_startup: ${{ inputs.sync_on_startup }}
          use_api_path: ${{ inputs.use_api_path }}
          debug: ${{ needs.validate.outputs.effective_debug }}
          check_service: true
          exit: false
          tunnel_host: ${{ inputs.enable_tunnel && 'bore.pub' || '' }}
          tunnel_ports: ${{ steps.tunnels.outputs.tunnel_ports }}

      - name: "Verify tunnel connectivity"
        if: inputs.enable_tunnel
        env:
          BORE_HOST: ${{ steps.tunnels.outputs.bore_host }}
          HTTP_PORT: ${{ steps.tunnels.outputs.http_port }}
          API_PATH: ${{ matrix.server.api_path }}
          USE_API_PATH: ${{ inputs.use_api_path }}
        run: |
          # Verify the tunnel is working by hitting Gerrit through it
          echo "Verifying tunnel connectivity..."

          EFFECTIVE_API_PATH=""
          if [ "${USE_API_PATH:-false}" = "true" ] && [ -n "$API_PATH" ]; then
            EFFECTIVE_API_PATH="$API_PATH"
          fi

          if [ -n "$EFFECTIVE_API_PATH" ]; then
            URL="http://${BORE_HOST}:${HTTP_PORT}${EFFECTIVE_API_PATH}/config/server/version"
          else
            URL="http://${BORE_HOST}:${HTTP_PORT}/config/server/version"
          fi

          echo "Testing: $URL"

          MAX_ATTEMPTS=5
          for i in $(seq 1 $MAX_ATTEMPTS); do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            if echo "$HTTP_CODE" | grep -q "200"; then
              VERSION=$(curl -s "$URL" | tr -d '")' | tail -1)
              echo "Tunnel verified ‚úÖ (Gerrit $VERSION)"
              exit 0
            fi
            echo "  Attempt $i/$MAX_ATTEMPTS failed, retrying..."
            sleep 3
          done

          echo "::warning::Could not verify tunnel connectivity"
          echo "Gerrit may still be starting up"

      - name: "Display connection info"
        env:
          USE_BORE: ${{ inputs.enable_tunnel }}
          TUNNEL_BORE_HOST: ${{ steps.tunnels.outputs.bore_host }}
          TUNNEL_HTTP_PORT: ${{ steps.tunnels.outputs.http_port }}
          TUNNEL_SSH_PORT: ${{ steps.tunnels.outputs.ssh_port }}
          TUNNEL_LOCAL_HTTP: ${{ steps.tunnels.outputs.local_http_port }}
          TUNNEL_LOCAL_SSH: ${{ steps.tunnels.outputs.local_ssh_port }}
          DEBUG_MINUTES: ${{ needs.validate.outputs.debug_minutes }}
          SERVER_NAME: ${{ matrix.server.name }}
          API_PATH: ${{ matrix.server.api_path }}
          SERVER_SLUG: ${{ matrix.server.slug }}
          USE_API_PATH: ${{ inputs.use_api_path }}
        run: |
          # Display connection information
          if [ "$USE_BORE" = "true" ]; then
            BORE_HOST="$TUNNEL_BORE_HOST"
            HTTP_PORT="$TUNNEL_HTTP_PORT"
            SSH_PORT="$TUNNEL_SSH_PORT"
            LOCAL_HTTP="$TUNNEL_LOCAL_HTTP"
            LOCAL_SSH="$TUNNEL_LOCAL_SSH"
          else
            BORE_HOST="localhost"
            HTTP_PORT="8080"
            SSH_PORT="29418"
            LOCAL_HTTP="8080"
            LOCAL_SSH="29418"
          fi

          declare -a TUNNELS=()

          EFFECTIVE_API_PATH=""
          if [ "${USE_API_PATH:-false}" = "true" ] && [ -n "$API_PATH" ]; then
            EFFECTIVE_API_PATH="$API_PATH"
          fi

          if [ -n "$HTTP_PORT" ]; then
            if [ -n "$EFFECTIVE_API_PATH" ]; then
              HTTP_URL="http://${BORE_HOST}:${HTTP_PORT}${EFFECTIVE_API_PATH}/"
            else
              HTTP_URL="http://${BORE_HOST}:${HTTP_PORT}/"
            fi
            TUNNELS+=("http|Web UI|$LOCAL_HTTP|$HTTP_PORT|$HTTP_URL")
          fi
          if [ -n "$SSH_PORT" ]; then
            SSH_URL="ssh://admin@${BORE_HOST}:${SSH_PORT}"
            TUNNELS+=("ssh|SSH/Git|$LOCAL_SSH|$SSH_PORT|$SSH_URL")
          fi

          {
            echo "# üîß Debug Session: $SERVER_NAME"
            echo ""
            echo "## üåê Public Access Ports"
            echo ""
            echo "| Service | Local Port | Public Port | Public URL |"
            echo "|---------|------------|-------------|------------|"

            for t in "${TUNNELS[@]}"; do
              IFS='|' read -r _ LABEL LOCAL PUBLIC URL <<< "$t"
              echo "| **$LABEL** | $LOCAL | $PUBLIC | \`$URL\` |"
            done

            echo ""
            echo "## üîó Quick Access"
            echo ""

            if [ -n "$HTTP_PORT" ]; then
              echo "### Gerrit Web Portal"
              echo ""
              if [ -n "$EFFECTIVE_API_PATH" ]; then
                echo "**URL**: http://$BORE_HOST:$HTTP_PORT$EFFECTIVE_API_PATH/"
              else
                echo "**URL**: http://$BORE_HOST:$HTTP_PORT/"
              fi
              echo ""
              echo '```bash'
              echo "# Check version"
              if [ -n "$EFFECTIVE_API_PATH" ]; then
                URL="http://$BORE_HOST:$HTTP_PORT$EFFECTIVE_API_PATH"
              else
                URL="http://$BORE_HOST:$HTTP_PORT"
              fi
              echo "curl -s $URL/config/server/version"
              echo ""
              echo "# List projects"
              echo "curl -s $URL/projects/"
              echo '```'
              echo ""
            fi

            if [ -n "$SSH_PORT" ]; then
              echo "### SSH Access"
              echo ""
              echo '```bash'
              echo "# Test connection"
              echo "ssh -p $SSH_PORT admin@$BORE_HOST gerrit version"
              echo ""
              echo "# Clone a repository"
              echo "git clone ssh://admin@$BORE_HOST:$SSH_PORT/PROJECT_NAME"
              echo '```'
              echo ""
            fi

            echo "## ‚è±Ô∏è Session Info"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| Server | $SERVER_NAME (\`$SERVER_SLUG\`) |"
            echo "| Duration | $DEBUG_MINUTES minutes |"
            DATE_FMT='+%Y-%m-%d %H:%M:%S %Z'
            EXPIRY=$(date -d "+$DEBUG_MINUTES minutes" "$DATE_FMT" \
              2>/dev/null || date -v+"${DEBUG_MINUTES}"M "$DATE_FMT")
            echo "| Expires | $EXPIRY |"
            echo ""
            if [ "$USE_BORE" = "true" ]; then
              echo "> ‚ö†Ô∏è **Warning**: URLs are publicly accessible!"
            else
              echo "> ‚ÑπÔ∏è **Note**: Local access only (external tunnel disabled)"
            fi
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          echo ""
          echo "========================================"
          echo "  DEBUG SESSION ACTIVE"
          echo "========================================"
          for t in "${TUNNELS[@]}"; do
            IFS='|' read -r _ LABEL _ _ URL <<< "$t"
            printf "  %-10s %s\n" "$LABEL:" "$URL"
          done
          echo "  Duration:  $DEBUG_MINUTES minutes"
          echo "========================================"
          echo ""

      - name: "Keep session alive"
        env:
          DEBUG_MINUTES: ${{ needs.validate.outputs.debug_minutes }}
          USE_BORE: ${{ inputs.enable_tunnel }}
        run: |
          # Keep the session alive for the specified duration
          echo "Session will remain active for $DEBUG_MINUTES minutes..."
          echo "Cancel the workflow manually when you're done debugging."
          echo ""

          TOTAL_SECONDS=$((DEBUG_MINUTES * 60))
          ELAPSED=0
          INTERVAL=60

          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            REMAINING=$(( (TOTAL_SECONDS - ELAPSED) / 60 ))
            echo "[$(date '+%H:%M:%S')] $REMAINING minutes remaining..."

            if [ "$USE_BORE" = "true" ]; then
              if ! pgrep -f "bore local" > /dev/null; then
                echo "::warning::bore tunnels have stopped unexpectedly"
                echo "HTTP tunnel log:"
                cat bore-http.log 2>/dev/null || echo "(no log)"
                echo "SSH tunnel log:"
                cat bore-ssh.log 2>/dev/null || echo "(no log)"
              fi
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "Debug session time expired."

      - name: "Cleanup"
        if: always()
        env:
          CONTAINER_IDS: ${{ steps.gerrit.outputs.container_ids }}
          USE_BORE: ${{ inputs.enable_tunnel }}
        run: |
          # Cleanup tunnels and containers
          echo "Cleaning up..."

          if [ "$USE_BORE" = "true" ]; then
            pkill -f "bore local" 2>/dev/null || true
          fi

          if [ -n "$CONTAINER_IDS" ]; then
            echo "$CONTAINER_IDS" | jq -r '.[]' 2>/dev/null | \
              while IFS= read -r cid; do
                [ -z "$cid" ] && continue
                echo "Stopping container: $cid"
                docker kill "$cid" 2>/dev/null || true
                echo "Removing container: $cid"
                docker rm "$cid" 2>/dev/null || true
              done
          fi

          echo "Cleanup complete ‚úÖ"

  ### Resync GitHub Organizations with Gerrit Content ###
  resync-orgs-prepare:
    name: "Prepare resync matrix"
    runs-on: ubuntu-latest
    needs: [validate, prepare]
    if: ${{ inputs.resync_orgs == true }}
    timeout-minutes: 5
    permissions:
      contents: read
    outputs:
      matrix: ${{ steps.build-matrix.outputs.matrix }}
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9  # v2.14.1
        with:
          egress-policy: audit

      - name: "Build resync matrix from GERRIT_SERVERS"
        id: build-matrix
        env:
          GERRIT_SERVERS: ${{ vars.GERRIT_SERVERS }}
          GITHUB_SELECTOR: ${{ inputs.github_selector }}
        run: |
          # Build matrix with all github orgs (github_org and github_gerrit_org)
          # Each entry maps a GitHub org to its source Gerrit server
          if [ -z "$GERRIT_SERVERS" ]; then
            echo "::error::GERRIT_SERVERS variable is not set"
            exit 1
          fi

          # Validate JSON
          if ! echo "$GERRIT_SERVERS" | jq empty 2>/dev/null; then
            echo "::error::GERRIT_SERVERS is not valid JSON"
            exit 1
          fi

          # Build full matrix: for each server, create entries for both
          # github_org and github_gerrit_org
          FULL_MATRIX=$(echo "$GERRIT_SERVERS" | jq -c '
            [.[] |
              {
                github_org: .github_org,
                gerrit: .gerrit,
                api_path: .api_path,
                name: .name,
                slug: .slug
              },
              {
                github_org: .github_gerrit_org,
                gerrit: .gerrit,
                api_path: .api_path,
                name: .name,
                slug: .slug
              }
            ]
          ')

          FULL_COUNT=$(echo "$FULL_MATRIX" | jq '. | length')
          echo "Full matrix has $FULL_COUNT GitHub organizations"

          # Apply github_selector filter
          if [ -z "$GITHUB_SELECTOR" ] || [ "$GITHUB_SELECTOR" = "all" ]; then
            # Empty selector or "all" = all orgs
            MATRIX="$FULL_MATRIX"
            echo "Using all $FULL_COUNT GitHub organizations (no selector)"
          else
            # Parse comma/space-separated selectors and support wildcards
            # Convert to newline-separated, trim whitespace
            SELECTORS=$(echo "$GITHUB_SELECTOR" | tr ',' '\n' | tr ' ' '\n' | \
              sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$')

            echo "GitHub org selectors to match:"
            echo "$SELECTORS"

            # Build jq filter for each selector (wildcards supported)
            # Convert shell wildcards to regex: * -> .*, ? -> .
            MATRIX=$(echo "$FULL_MATRIX" | jq -c --arg selectors "$SELECTORS" '
              ($selectors | split("\n")) as $sels |
              [.[] | . as $org |
                select(
                  any($sels[]; . as $sel |
                    if ($sel | contains("*")) or ($sel | contains("?")) then
                      # Convert glob to regex: * -> .*, ? -> .
                      ($sel | gsub("\\*"; ".*") | gsub("\\?"; ".")) as $regex |
                      ($org.github_org | test("^" + $regex + "$"))
                    else
                      $org.github_org == $sel
                    end
                  )
                )
              ]
            ')
            MATCH_COUNT=$(echo "$MATRIX" | jq '. | length')
            if [ "$MATCH_COUNT" -eq 0 ]; then
              echo "::error::No GitHub orgs matched selector: $GITHUB_SELECTOR"
              echo "Available GitHub organizations:"
              echo "$FULL_MATRIX" | jq -r '.[].github_org'
              exit 1
            fi
            echo "Matched $MATCH_COUNT orgs (selector: $GITHUB_SELECTOR)"
          fi

          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          COUNT=$(echo "$MATRIX" | jq '. | length')
          echo "Resync matrix prepared with $COUNT GitHub organizations"
          echo "$MATRIX" | jq '.'

  resync-orgs:
    name: "Resync: ${{ matrix.org.github_org }}"
    runs-on: ubuntu-latest
    needs: [validate, resync-orgs-prepare]
    if: ${{ inputs.resync_orgs == true }}
    permissions:
      contents: read
    timeout-minutes: 120
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        org: ${{ fromJSON(needs.resync-orgs-prepare.outputs.matrix) }}
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9  # v2.14.1
        with:
          egress-policy: audit

      - name: "Install gerrit-clone CLI"
        run: |
          # Install uv if not available
          if ! command -v uv &> /dev/null; then
            echo "Installing uv..."
            curl -LsSf https://astral.sh/uv/install.sh | sh
            export PATH="$HOME/.cargo/bin:$PATH"
          fi

          # Create wrapper for gerrit-clone
          mkdir -p "$HOME/.local/bin"
          cat > "$HOME/.local/bin/gerrit-clone" << 'WRAPPER'
          #!/bin/bash
          exec uvx gerrit-clone "$@"
          WRAPPER
          chmod +x "$HOME/.local/bin/gerrit-clone"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"
          export PATH="$HOME/.local/bin:$PATH"

          # Verify installation
          gerrit-clone --version

      - name: "Reset GitHub org: ${{ matrix.org.github_org }}"
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
          GITHUB_ORG: ${{ matrix.org.github_org }}
        run: |
          # Forcibly remove all repositories from the GitHub organization
          echo "Resetting GitHub organization: $GITHUB_ORG"
          echo "WARNING: This will delete ALL repositories in $GITHUB_ORG"

          gerrit-clone reset \
            --org "$GITHUB_ORG" \
            --no-confirm \
            --verbose

          echo "Reset complete for $GITHUB_ORG"

      - name: "Mirror Gerrit to GitHub: ${{ matrix.org.github_org }}"
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
          GITHUB_ORG: ${{ matrix.org.github_org }}
          GERRIT_SERVER: ${{ matrix.org.gerrit }}
        run: |
          # Mirror all Gerrit content to the GitHub organization
          echo "Mirroring from $GERRIT_SERVER to $GITHUB_ORG"

          gerrit-clone mirror \
            --server "$GERRIT_SERVER" \
            --org "$GITHUB_ORG" \
            --output-path "/tmp/mirror-${GITHUB_ORG}" \
            --discovery-method http \
            --https \
            --recreate \
            --overwrite \
            --verbose

          echo "Mirror complete for $GITHUB_ORG"

      - name: "Report results"
        if: always()
        env:
          GITHUB_ORG: ${{ matrix.org.github_org }}
          GERRIT_SERVER: ${{ matrix.org.gerrit }}
        run: |
          {
            echo "## Resync: $GITHUB_ORG"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| GitHub Org | \`$GITHUB_ORG\` |"
            echo "| Gerrit Server | \`$GERRIT_SERVER\` |"
            echo "| Status | ${{ job.status }} |"
            echo ""
            if [ -f "/tmp/mirror-${GITHUB_ORG}/mirror-manifest.json" ]; then
              echo "### Mirror Results"
              echo '```json'
              jq '{total, succeeded, failed, skipped, duration_s}' \
                "/tmp/mirror-${GITHUB_ORG}/mirror-manifest.json"
              echo '```'
            fi
          } >> "$GITHUB_STEP_SUMMARY"


  ### Summary job ###
  summary:
    name: "Test Summary"
    runs-on: ubuntu-latest
    timeout-minutes: 3
    needs: [validate, prepare, sync-test, persist-gerrit, resync-orgs]
    if: always()
    permissions:
      contents: read
    steps:
      - name: "Generate summary"
        env:
          DEBUG_MINUTES: ${{ needs.validate.outputs.debug_minutes }}
          DEBUG_COUNT: ${{ needs.prepare.outputs.debug_count }}
        run: |
          # Generate test summary
          {
            echo "# Gerrit Server Test Results üìä"
            echo ""
            echo "| Status | Details |"
            echo "|--------|---------|"
            echo "| Validation | ${{ needs.validate.result }} |"
            echo "| Preparation | ${{ needs.prepare.result }} |"
            echo "| Sync Tests | ${{ needs.sync-test.result }} |"
            if [ "$DEBUG_MINUTES" != "0" ]; then
              echo "| Debug Sessions ($DEBUG_COUNT) \
                | ${{ needs.persist-gerrit.result }} |"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: "Check overall result"
        if: needs.sync-test.result != 'success'
        run: |
          echo "::error::One or more Gerrit server tests failed"
          exit 1
